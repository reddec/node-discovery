// Generated by CoffeeScript 1.8.0
(function() {
  var EventEmitter, INTERVAL, METHOD_ECHO, METHOD_FORCE_FIND, MULTICAST_IP, MULTICAST_PORT, Service, dgram,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  dgram = require('dgram');

  EventEmitter = require('events').EventEmitter;

  METHOD_FORCE_FIND = 'force';

  METHOD_ECHO = 'echo';

  INTERVAL = 2000;

  MULTICAST_IP = '239.155.155.150';

  MULTICAST_PORT = 22000;


  /*
  * Simple service discovery over UDP multicast
  * Emits events with name of catched service description
  * Custom event '*' catches all messages (except own or force)
   */

  Service = (function(_super) {
    __extends(Service, _super);


    /*
    * Create new instance of discovery service and
    * join to muticast
    * @param {string} Name of service. Messages from
    * services with same name will not be catched
    * @param {number} Multicast port
    * @param {string} Multicast IP
    * @param {number} Sending interval
     */

    function Service(name, port, ip, interval) {
      this.name = name;
      this.port = port != null ? port : MULTICAST_PORT;
      this.ip = ip != null ? ip : MULTICAST_IP;
      if (interval == null) {
        interval = INTERVAL;
      }
      this.sendAbout = __bind(this.sendAbout, this);
      this.close = __bind(this.close, this);
      this.force = __bind(this.force, this);
      this.add = __bind(this.add, this);
      this.on_message = __bind(this.on_message, this);
      this.names = {};
      this.socket = dgram.createSocket('udp4');
      this.socket.bind(this.port, (function(_this) {
        return function() {
          _this.socket.addMembership(_this.ip);
          return console.log("Joined to", _this.ip, "as", _this.name);
        };
      })(this));
      this.socket.on('message', this.on_message);
      this.timer = setInterval(this.sendAbout, interval);
    }


    /*
    * Listener for incoming UDP messages
     */

    Service.prototype.on_message = function(msg, rinfo) {
      var ip;
      msg = JSON.parse(msg.toString());
      ip = rinfo.address;
      if (msg.method === METHOD_FORCE_FIND) {
        return this.sendAbout();
      }
      if (msg.name === this.name) {
        return;
      }
      this.emit(msg.name, msg.name, ip, msg.data);
      return this.emit('*', msg.name, ip, msg.data);
    };


    /*
    * Add new service (logical) description
    * @param {string} Name of service.
    * @param {object} Serializeable description
    * @return {Service} itself
     */

    Service.prototype.add = function(name, data) {
      this.names[name] = data;
      return this;
    };


    /*
    * Force request descriptions from services
    * @return {Service} itself
     */

    Service.prototype.force = function() {
      var msg;
      msg = {
        method: METHOD_FORCE_FIND,
        name: this.name
      };
      msg = new Buffer(JSON.stringify(msg));
      this.socket.send(msg, 0, msg.length, this.port, this.ip);
      return this;
    };


    /*
    * Close sockets and remove all listeners
    * @return {Service} itself
     */

    Service.prototype.close = function() {
      this.removeAllListeners();
      this.socket.close();
      clearInterval(this.timer);
      return this;
    };


    /*
    * Send self description to multicast group
    * @return {Service} itself
     */

    Service.prototype.sendAbout = function() {
      var msg;
      msg = {
        method: METHOD_ECHO,
        name: this.name,
        data: this.names
      };
      msg = new Buffer(JSON.stringify(msg));
      this.socket.send(msg, 0, msg.length, this.port, this.ip);
      return this;
    };

    return Service;

  })(EventEmitter);

  module.exports = Service;

}).call(this);
